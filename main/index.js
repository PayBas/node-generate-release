// Generated by CoffeeScript 1.10.0

/*
  Generate Release
  Kevin Gravier
  MIT License
 */

(function() {
  var Exec, FS, Inquirer, Minimist, Options, Path, Promise, askConfirmUpdate, askReleaseType, incrementVersion, postGitCommands, preGitCommands, readVersionFromPackageFile, writeNewVersionPackage, writeNewVersionToReadme;

  Inquirer = require('inquirer');

  Promise = require('bluebird');

  FS = require('fs');

  Exec = require('child_process').execSync;

  Path = require('path');

  Minimist = require('minimist');

  Options = require('./lib/Options');

  askReleaseType = require('./lib/askReleaseType');

  incrementVersion = require('./lib/incrementVersion');

  askConfirmUpdate = require('./lib/askConfirmUpdate');

  readVersionFromPackageFile = function(package_file_location) {
    var version;
    version = require(Path.resolve(package_file_location)).version;
    if (!version) {
      throw new Error("Could not read current version from package file: " + package_file_location);
    }
    return version;
  };

  writeNewVersionToReadme = function(readme_path, current_version, new_version) {
    var file, new_file, real_path;
    real_path = Path.resolve(readme_path);
    file = FS.readFileSync(real_path);
    new_file = file.toString().replace(current_version, new_version);
    return FS.writeFileSync(real_path, new_file, 'utf8');
  };

  writeNewVersionPackage = function(package_path, current_version, new_version) {
    var pack, pack_string;
    pack = require(package_path);
    pack.version = new_version;
    pack_string = JSON.stringify(pack, null, 2);
    pack_string += '\n';
    return FS.writeFileSync(package_path, pack_string, 'utf8');
  };

  preGitCommands = function(new_version) {
    var opts;
    opts = {
      env: process.env
    };
    Exec('git fetch', opts);
    Exec('git checkout develop', opts);
    Exec('git pull origin develop --rebase', opts);
    Exec('git checkout master', opts);
    Exec('git reset --hard origin/master', opts);
    Exec('git checkout develop', opts);
    return Exec("git flow release start " + new_version, opts);
  };

  postGitCommands = function(new_version) {
    var opts;
    opts = {
      env: process.env
    };
    opts.env.GIT_MERGE_AUTOEDIT = 'no';
    Exec('git add README.md package.json', opts);
    Exec("git commit -am \"Release " + new_version + "\"", opts);
    Exec("git flow release finish -m \"" + new_version + "\" " + new_version, opts);
    Exec('git push origin develop', opts);
    Exec('git push origin master', opts);
    return Exec('git push origin --tags', opts);
  };

  module.exports = function(args) {
    var options;
    options = new Options();
    return Promise["try"](function() {
      return args.slice(2);
    }).then(Minimist).then(function(args) {
      return options.parseArgs(args);
    }).then(function() {
      if (!options.release_type) {
        return askReleaseType().then(function(release_type) {
          return options.release_type = release_type;
        });
      }
    }).then(function() {
      if (!options.current_version) {
        options.current_version = readVersionFromPackageFile(options.package_file_location);
      }
      return options.next_version = incrementVersion(options.current_version, options.release_type);
    }).then(function() {
      return options.no_confirm || (askConfirmUpdate(options.current_version, options.next_version));
    }).then(function(do_update) {
      if (!do_update) {
        throw new Error('Update Canceled');
      }
    }).then(function() {
      return preGitCommands(options.next_version);
    }).then(function() {
      return writeNewVersionToReadme(options.readme_file_location, options.current_version, options.next_version);
    }).then(function() {
      return writeNewVersionPackage(options.package_file_location, options.current_version, options.next_version);
    }).then(function() {
      return postGitCommands(options.next_version);
    })["catch"](function(err) {
      console.log(err.message);
      return process.exit(1);
    });
  };

}).call(this);
