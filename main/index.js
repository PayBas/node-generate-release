// Generated by CoffeeScript 1.10.0

/*
  Generate Release
  Kevin Gravier
  MIT License
 */

(function() {
  var ChildProcess, GitCommands, IS_DEBUG, IS_TEST, Minimist, Options, PackageFile, ParseSpawnArgs, Promise, askConfirmUpdate, askReleaseType, incrementVersion, writeNewReadme;

  IS_DEBUG = process.env.IS_DEBUG != null;

  IS_TEST = process.env.IS_TEST != null;

  Promise = require('bluebird');

  Minimist = require('minimist');

  ChildProcess = require('child_process');

  ParseSpawnArgs = require('parse-spawn-args');

  Options = require('./lib/Options');

  GitCommands = require('./lib/GitCommands');

  PackageFile = require('./lib/PackageFile');

  askReleaseType = require('./lib/askReleaseType');

  incrementVersion = require('./lib/incrementVersion');

  askConfirmUpdate = require('./lib/askConfirmUpdate');

  writeNewReadme = require('./lib/writeNewReadme');

  module.exports = function(args) {
    var options, package_file;
    options = new Options();
    package_file = new PackageFile();
    return Promise["try"](function() {
      return args.slice(2);
    }).then(Minimist).then(function(args) {
      return options.parseArgs(args);
    }).then(function() {
      if (!IS_TEST) {
        return GitCommands.checkForCleanWorkingDirectory();
      }
    }).then(function() {
      if (!options.release_type) {
        return askReleaseType().then(function(release_type) {
          return options.release_type = release_type;
        });
      }
    }).then(function() {
      return package_file.load(options.package_file_location);
    }).then(function() {
      if (!options.current_version) {
        options.current_version = package_file.getVersion();
      }
      return options.next_version = incrementVersion(options.current_version, options.release_type);
    }).then(function() {
      return options.no_confirm || (askConfirmUpdate(options.current_version, options.next_version));
    }).then(function(do_update) {
      if (!do_update) {
        throw new Error('Update Canceled');
      }
    }).then(function() {
      if (!IS_TEST) {
        return GitCommands.preCommands(options.next_version, options.skip_git_pull);
      } else {
        return console.info("TEST: GitCommands.preCommands " + options.next_version + ", " + options.skip_git_pull);
      }
    }).then(function() {
      if (!IS_TEST) {
        return writeNewReadme(options.readme_file_location, options.current_version, options.next_version);
      } else {
        return console.info("TEST: writeNewReadme " + options.readme_file_location + ", " + options.current_version + ", " + options.next_version);
      }
    }).then(function() {
      if (!IS_TEST) {
        package_file.setVersion(options.next_version);
        return package_file.save();
      } else {
        return console.info("TEST: package_file.setVersion " + options.next_version + " && package_file.save()");
      }
    }).then(function() {
      var command, command_array, command_string, i, j, len, len1, ref, ref1, results, results1, ret;
      if (!IS_TEST) {
        ref = options.pre_commit_commands;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          command_string = ref[i];
          command_array = ParseSpawnArgs.parse(command_string);
          command = command_array.shift();
          ret = ChildProcess.spawnSync(command, command_array);
          if (!ret) {
            throw ret.error;
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        ref1 = options.pre_commit_commands;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          command = ref1[j];
          results1.push(console.info("TEST: EXEC: " + command));
        }
        return results1;
      }
    }).then(function() {
      var files;
      files = [options.readme_file_location, options.package_file_location].concat(options.additional_files_to_commit);
      if (!IS_TEST) {
        return GitCommands.postCommands(options.next_version, files, options.skip_git_push);
      } else {
        return console.info("TEST: GitCommands.postCommands " + options.next_version + ", " + files + ", " + options.skip_git_push);
      }
    }).then(function() {
      var command, command_array, command_string, i, j, len, len1, ref, ref1, results, results1, ret;
      if (!IS_TEST) {
        ref = options.post_commit_commands;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          command_string = ref[i];
          command_array = ParseSpawnArgs.parse(command_string);
          command = command_array.shift();
          ret = ChildProcess.spawnSync(command, command_array);
          if (!ret) {
            throw ret.error;
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        ref1 = options.post_commit_commands;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          command = ref1[j];
          results1.push(console.info("TEST: EXEC: " + command));
        }
        return results1;
      }
    })["catch"](function(err) {
      if (IS_DEBUG) {
        throw err;
      }
      console.log(err.message);
      return process.exit(1);
    });
  };

}).call(this);
