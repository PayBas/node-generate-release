// Generated by CoffeeScript 1.10.0

/*
  Generate Release
  Kevin Gravier
  MIT License
 */

(function() {
  var GitCommands, GitFlowSettings, Glob, IS_DEBUG, IS_TEST, Minimist, Options, PackageFile, Path, Promise, askConfirmUpdate, askReleaseType, incrementVersion, runArbitraryCommand, writeNewReadme;

  IS_DEBUG = process.env.IS_DEBUG != null;

  IS_TEST = process.env.IS_TEST != null;

  Promise = require('bluebird');

  Minimist = require('minimist');

  Glob = require('glob');

  Path = require('path');

  Options = require('./lib/Options');

  GitCommands = require('./lib/GitCommands');

  PackageFile = require('./lib/PackageFile');

  GitFlowSettings = require('./lib/GitFlowSettings');

  askReleaseType = require('./lib/askReleaseType');

  incrementVersion = require('./lib/incrementVersion');

  askConfirmUpdate = require('./lib/askConfirmUpdate');

  writeNewReadme = require('./lib/writeNewReadme');

  runArbitraryCommand = require('./lib/runArbitraryCommand');

  module.exports = function(args) {
    var git_flow_settings, options, package_file;
    options = void 0;
    package_file = void 0;
    git_flow_settings = void 0;
    return Promise["try"](function() {
      return args.slice(2);
    }).then(Minimist).then(function(mArgs) {
      return options = new Options(mArgs);
    }).then(function() {
      return options.parse();
    }).then(function() {
      return git_flow_settings = new GitFlowSettings(Path.resolve('./'));
    }).then(function() {
      return git_flow_settings.parseIni();
    }).then(function() {
      if (!IS_TEST) {
        return GitCommands.checkForCleanWorkingDirectory();
      }
    }).then(function() {
      if (!options.release_type) {
        return askReleaseType().then(function(release_type) {
          return options.release_type = release_type;
        });
      }
    }).then(function() {
      return package_file = new PackageFile(options.package_file_location);
    }).then(function() {
      return package_file.load();
    }).then(function() {
      if (!options.current_version) {
        return options.current_version = package_file.getVersion();
      }
    }).then(function() {
      return options.next_version = incrementVersion(options.current_version, options.release_type, git_flow_settings.version_tag_prefix);
    }).then(function() {
      return options.no_confirm || (askConfirmUpdate(options.current_version, options.next_version));
    }).then(function(do_update) {
      if (!do_update) {
        throw new Error('Update Canceled');
      }
    }).then(function() {
      if (!IS_TEST) {
        return GitCommands.preCommands(options.next_version, options.skip_git_pull, git_flow_settings.master, git_flow_settings.develop);
      } else {
        return console.info("TEST: GitCommands.preCommands " + options.next_version + ", " + options.skip_git_pull + ", " + git_flow_settings.master + ", " + git_flow_settings.develop);
      }
    }).then(function() {
      if (!IS_TEST) {
        return writeNewReadme(options.readme_file_location, options.current_version, options.next_version);
      } else {
        return console.info("TEST: writeNewReadme " + options.readme_file_location + ", " + options.current_version + ", " + options.next_version);
      }
    }).then(function() {
      if (!IS_TEST) {
        package_file.setVersion(options.next_version);
        return package_file.save();
      } else {
        return console.info("TEST: package_file.setVersion " + options.next_version + " && package_file.save()");
      }
    }).then(function() {
      var command, i, len, ref, results;
      if (!IS_TEST) {
        return Promise["try"](function() {
          var command, i, len, ref, results;
          ref = options.pre_commit_commands;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            command = ref[i];
            results.push(runArbitraryCommand(command));
          }
          return results;
        })["catch"](function(err) {
          GitCommands.reset(options.next_version, git_flow_settings.master, git_flow_settings.develop);
          throw err;
        });
      } else {
        ref = options.pre_commit_commands;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          command = ref[i];
          results.push(console.info("TEST: EXEC: " + command));
        }
        return results;
      }
    }).then(function() {
      var file, files, i, j, len, len1, ref, tmp_file, tmp_files;
      files = [options.readme_file_location, options.package_file_location];
      ref = options.additional_files_to_commit;
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        tmp_files = Glob.sync(file);
        for (j = 0, len1 = tmp_files.length; j < len1; j++) {
          tmp_file = tmp_files[j];
          files.push(Path.resolve(tmp_file));
        }
      }
      if (!IS_TEST) {
        return GitCommands.postCommands(options.next_version, files, options.skip_git_push, git_flow_settings.master, git_flow_settings.develop);
      } else {
        return console.info("TEST: GitCommands.postCommands " + options.next_version + ", " + files + ", " + options.skip_git_push + ", " + git_flow_settings.master + ", " + git_flow_settings.develop);
      }
    }).then(function() {
      var command, i, len, promises, ref, results;
      if (!IS_TEST) {
        promises = (function() {
          var i, len, ref, results;
          ref = options.post_commit_commands;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            command = ref[i];
            results.push(Promise["try"](function() {
              return runArbitraryCommand(command);
            })["catch"](function() {}));
          }
          return results;
        })();
        return Promise.all(promises);
      } else {
        ref = options.post_commit_commands;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          command = ref[i];
          results.push(console.info("TEST: EXEC: " + command));
        }
        return results;
      }
    })["catch"](function(err) {
      if (IS_DEBUG) {
        throw err;
      }
      console.log(err.message);
      return process.exit(1);
    });
  };

}).call(this);
