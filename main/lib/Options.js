// Generated by CoffeeScript 1.10.0

/*
  Generate Release
  Kevin Gravier
  MIT License
 */

(function() {
  var HelpError, Options, Path, args, bool, existsSync, extend, pick, release_file_allowed_keys;

  existsSync = require('exists-sync');

  Path = require('path');

  bool = require('@nkcmr/bool');

  pick = require('object-pick');

  extend = require('extend');

  HelpError = require('./HelpError');

  args = {
    show_help: ['h', 'help'],
    readme_file_location: ['r', 'readme'],
    package_file_location: ['p', 'package'],
    dot_release_file_location: ['d', 'release-file'],
    current_version: ['c', 'current-version'],
    release_type: ['t', 'release-type'],
    no_confirm: ['n', 'no-confirm'],
    skip_git_pull: ['l', 'skip-git-pull'],
    skip_git_push: ['s', 'skip-git-push']
  };

  release_file_allowed_keys = ['readme_file_location', 'package_file_location', 'no_confirm', 'skip_git_pull', 'skip_git_push', 'pre_commit_commands', 'additional_files_to_commit'];

  Options = (function() {
    function Options() {}

    Options.prototype.readme_file_location = './README.md';

    Options.prototype.package_file_location = './package.json';

    Options.prototype.dot_release_file_location = './.release.json';

    Options.prototype.no_confirm = false;

    Options.prototype.release_type = null;

    Options.prototype.current_version = null;

    Options.prototype.skip_git_pull = false;

    Options.prototype.skip_git_push = false;

    Options.prototype.pre_commit_commands = [];

    Options.prototype.additional_files_to_commit = [];

    Options.prototype.validation_error = '\n';

    Options.prototype.readArgsFromFile = function() {
      var file_properties;
      if (existsSync(this.dot_release_file_location)) {
        file_properties = require(this.dot_release_file_location);
        return extend(this, pick(file_properties, release_file_allowed_keys));
      }
    };

    Options.prototype.parseArgs = function(args) {
      this.args = args;
      if (this.getArgumentValue('show_help')) {
        throw new HelpError;
      }
      this.readme_file_location = Path.resolve((this.getArgumentValue('readme_file_location')) || this.readme_file_location);
      this.package_file_location = Path.resolve((this.getArgumentValue('package_file_location')) || this.package_file_location);
      this.dot_release_file_location = Path.resolve((this.getArgumentValue('dot_release_file_location')) || this.dot_release_file_location);
      this.release_type = (this.getArgumentValue('release_type')) || this.release_type;
      this.no_confirm = (this.getArgumentValue('no_confirm')) || this.no_confirm;
      this.current_version = (this.getArgumentValue('current_version')) || this.current_version;
      this.skip_git_pull = (this.getArgumentValue('skip_git_pull')) || this.skip_git_pull;
      this.skip_git_push = (this.getArgumentValue('skip_git_push')) || this.skip_git_push;
      this.readArgsFromFile();
      return this.validateArguments();
    };

    Options.prototype.validateArguments = function() {
      return (this.validateReadmeFileLocation() && this.validatePackageFileLocation() && this.validateReleaseType() && this.validateNoConfirm() && this.validateSkipGitPull() && this.validateSkipGitPush() && this.validatePreCommitCommands() && this.validateAdditionalFilesToCommit()) || (function() {
        throw new HelpError(this.validation_error);
      }).call(this);
    };

    Options.prototype.validateReadmeFileLocation = function() {
      if (!existsSync(this.readme_file_location)) {
        this.validation_error += "Readme does not exist: " + this.readme_file_location + "\n";
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validatePackageFileLocation = function() {
      if (!existsSync(this.package_file_location)) {
        this.validation_error += "Package file does not exist: " + this.package_file_location + "\n";
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateCurrentVersion = function() {
      if (!((!this.current_version) || (this.current_version.test(/(\d+\.){2}\d+/)))) {
        this.validation_error += "Invalid current version: " + this.current_version + "\n";
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateReleaseType = function() {
      var ref;
      if (!((!this.release_type) || ((ref = this.release_type) === 'patch' || ref === 'minor' || ref === 'major'))) {
        this.validation_error += "Unknown release type: " + this.release_type + "\n";
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateNoConfirm = function() {
      if (typeof this.no_confirm !== 'boolean') {
        this.validation_error += 'Invalid value for no-confirm\n';
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateSkipGitPush = function() {
      if (typeof this.skip_git_push !== 'boolean') {
        this.validation_error += 'Invalid value for skip-git-push\n';
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateSkipGitPull = function() {
      if (typeof this.skip_git_pull !== 'boolean') {
        this.validation_error += 'Invalid value for skip-git-pull\n';
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validatePreCommitCommands = function() {
      if (!Array.isArray(this.pre_commit_commands)) {
        this.validation_error += 'Pre Git Commands must be an array';
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.validateAdditionalFilesToCommit = function() {
      if (!Array.isArray(this.additional_files_to_commit)) {
        this.validation_error += 'Additional Files to Commit must be an array';
        return false;
      } else {
        return true;
      }
    };

    Options.prototype.getArgumentValue = function(argument) {
      var arg, t;
      t = this;
      return ((function() {
        var i, len, ref, results;
        ref = args[argument];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          arg = ref[i];
          if (t.args[arg]) {
            results.push(t.args[arg]);
          }
        }
        return results;
      })())[0];
    };

    return Options;

  })();

  module.exports = Options;

}).call(this);
